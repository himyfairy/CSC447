[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/play/README.scala","languageId":"scala","version":1,"text":"// The src directory is meant for code that will be run with automated tests.\n// Put other code in this directory.\n//\n// sbt requires that all files in src/main/scala must compile.\n// That can be a pain when you want to experiment.\n//\n// In the scala console, you can load this file by typing\n//    scala> :load play/README.scala\n//    scala> length1(xs)\n//\n\n/*\nval xs = List(11, 21, 31)\nval xss = List(List(11, 21), List(), List(31), List(41, 51, 61))\n\ndef log[X](prefix: String, d: Int = 0)(computeResult: => X) =\n  val indent = \"  \" * d\n  println(s\"${indent}${prefix}\")\n  val result = computeResult\n  println(s\"${indent}${prefix} : ${result}\")\n  result\n\n*/\n\n// This is the length function from the first lecture on scala, with logging\n// This version is right recursive, computing the operator with the RESULT of\n// recursive call.\n\n/*\ndef length1[X](xs: List[X]): Int =\nlog(s\"length($xs)\") {\n  xs match\n    case Nil     => 0\n    case _ :: ys => 1 + length1(ys)\n}\n\n*/\n\n// Here is a version that recurs into the parameter instead of the result. This\n// version is left recursive, AKA tail recursive, computing the operator into a\n// PARAMETER of the recursive call.\n//\n// This version also uses the optional parameter d to indicate the call depth.\n\n/*\ndef length2[X](xs: List[X], accumulator: Int = 0, d: Int = 0): Int =\n  log(s\"length($xs, $accumulator)\", d) {\n    xs match\n      case Nil     => accumulator\n      case _ :: ys => length2(ys, 1 + accumulator, d + 1)\n  }\n\n  */\n\n// Try this:\n//    scala> :load play/README.scala\n//    scala> length1(xs)\n//    scala> length2(xs)\n// Try changing length1 to use a depth parameter for indentation.\n\n// @main def m() = \n//   println(\"hello world\")\n\n// @main def m(args: String*) = \n//   println(\"hello, \" + args(0) + \"!\")\n\n// @main def m(name: String) = \n//   println(\"hello, \" + name + \"!\")\n\n// @main def m(name: String*) = \n//   var i = 0\n//   while i < name.length do\n//     println(name(i))\n//     i += 1\n\n// @main def m(name: String*) = \n//   var i = 0\n//   while i < name.length do\n//     if i!= 0 then\n//       print(\" \")\n//     print(name(i))\n//     i += 1\n//   println()\n\n// @main def m(args: String*) = \n//   args.foreach((a: String) => println(a))\n\n// @main def m(args: String*) = \n//   args.foreach(println)\n\n// @main def m(args: String*) = \n//   for a <- args do\n//     println(a)\n\n// var big = new java.math.BigInteger(\"123\")\n\n// @main def fun() = \n//   val greetStr = new Array[String](3)\n//   greetStr(0) = \"qilu\"\n//   greetStr(1) = \"is\"\n//   greetStr(2) = \"p1\"\n//   for i <- 0 to 2 do\n//     println(greetStr(i))\n\n//   for a <- greetStr do\n//     println(a)\n\n//   greetStr.foreach(str => println(str))\n\n// @main def fun() = \n//   val greetStr = new Array[String](3)\n//   greetStr.update(0, \"qilu\")\n//   greetStr.update(1, \"is\")\n//   greetStr.update(2, \"p1\")\n//   for i <- 0.to(2) do\n//     println(greetStr(i))\n\n// @main def fun() = \n//   val l1 = List(1, 2)\n//   val l2 = List(3, 4)\n//   val l3 = l1 ::: l2\n//   val l4 = List(2, 3)\n//   val l5 = 1 :: l4\n//   val l6 = 1 :: 2 :: 3 :: 4 :: 5 :: Nil\n//   println(\"l1 is \" + l1)\n//   println(\"l2 is \" + l2)\n//   println(\"l3 is \" + l3)\n//   println(\"l4 is \" + l4)\n//   println(\"l5 is \" + l5)\n//   println(\"l6 is \" + l6)\n\nimport java.util.NoSuchElementException\nimport scala.collection.mutable\nimport scala.collection.immutable\nimport scala.compiletime.ops.int\nimport scala.language.postfixOps\nimport scala.io.StdIn.readLine\nimport scala.compiletime.ops.string\nimport scala.annotation.tailrec\n// import T.*\n\nobject test66:\n\n  def log[X](prefix: String)(computeResult: => X) =\n    println(prefix)\n    val result = computeResult\n    println(s\"prefix $prefix : rs $result\")\n    result\n\n  def fact(n: Int): Int =\n    if n <= 1 then 1\n    else n * fact(n - 1)\n\n  def factLog(n: Int): Int =\n    log(s\"fact($n)\") {\n      if n <= 1 then 1\n      else n * factLog(n - 1)\n    }\n\n  def fib(n: Int): Int =\n  // TODO: Provide definition here.\n    if n < 0 then\n      throw UnsupportedOperationException()\n    if n == 0 || n == 1 then n\n    else fib(n-1) + fib(n-2)\n\n  def sum(xs: List[Int]) : Int =\n    if xs.isEmpty then throw UnsupportedOperationException()\n    if xs.length == 1 then xs.head\n    else xs.head + sum(xs.tail)\n  \n  def max(xs: List[Int]): Int =\n    if xs.isEmpty then throw java.util.NoSuchElementException()\n    if xs.length == 1 then xs.head\n    else (xs.head max max(xs.tail))\n\n  def otpu(start: Int, end: Int): List[Int] =\n    if start < end then Nil\n    else start :: otpu(start-1, end)\n\n  def formatArgs(args: List[String]) = args.mkString(\"\\n\")\n\n  def sumTailAux(xs: List[Int], accumulator: Int): Int =\n    xs match\n      case Nil     => accumulator\n      case y :: ys => sumTailAux(ys, accumulator + y)\n  \n  def sumTail(xs: List[Int]): Int =\n    if xs.isEmpty then throw UnsupportedOperationException()\n    else sumTailAux(xs.tail, xs.head)\n\n  def maxTailAux(xs: List[Int], accumulator: Int): Int =\n    if xs.length == 1 then (accumulator max xs.head)\n    else (accumulator max maxTailAux(xs.tail, xs.head))\n\n  def maxTail(xs: List[Int]): Int =\n    xs match\n      case Nil     => throw NoSuchElementException()\n      case y :: ys => maxTailAux(ys, y)\n\n  def ***() = \n    println(\"---\")\n\n  def fileLines(file: java.io.File) =\n    scala.io.Source.fromFile(file).getLines().toArray\n\n  def gcdLoop(x: Long, y: Long): Long =\n    var a = x\n    var b = y\n    while a != 0 do\n      val temp = a\n      a = b % a\n      b = temp\n      println(s\"---a:$a b:$b\")\n    b\n  \n  def printMultiTable() =\n    var i = 1\n    // only i in scope here\n    while i <= 10 do\n      var j = 1\n      // both i and j in scope here\n      while j <= 10 do\n        val prod = (i * j).toString\n        // i, j, and prod in scope here\n        var k = prod.length\n        // i, j, prod, and k in scope here\n        while k < 4 do\n          print(\" \")\n          k += 1\n        print(prod)\n        j += 1\n        // i and j still in scope; prod and k out of scope\n      println()\n      i += 1\n    // i still in scope; j, prod, and k out of scope\n\n  def twice(op: Double => Double, x: Double) = op(op(x))\n\n  def isort(xs: List[Int]): List[Int] =\n    if xs.isEmpty then Nil\n    else insert(xs.head, isort(xs.tail))\n\n  def insert(x: Int, xs: List[Int]): List[Int] =\n    if xs.isEmpty || x <= xs.head then x :: xs\n    else xs.head :: insert(x, xs.tail)\n\n  // def append[T](xs: List[T], ys: List[T]): List[T] =\n  //   xs match\n  //   case List() => ys\n  //   case x :: xs1 => x :: append(xs1, ys)\n    // case x :: xs1 => x :: xs1 :: ys\n\n\n  def map[A, B](xs: List[A], f: A => B): List[B] =\n    xs match\n      case List() => Nil\n      case x::xs1 => f(xs.head) :: map(xs.tail, f)\n  \n  def myfilter[A](xs: List[A], f: A => Boolean): List[A] =\n    xs match\n      case List() => Nil\n      case x::xs1 => \n        if f(xs.head) then xs.head :: myfilter(xs.tail, f)\n        else myfilter(xs.tail, f)\n\n  def append[A](xs: List[A], ys: List[A]): List[A] =\n    xs match\n      case List() => ys\n      case x :: xs1 => x :: append(xs1, ys)\n\n  // def myappend[A](xs: List[A], ys: List[A]): List[A] =\n  //   ys match\n  //     case List() => xs\n  //     case y::ys1 =>\n  //       val newlist[A] = xs:::ys.head\n  //       myappend(newlist, ys.tail)\n\n  def flatten[A](xss: List[List[A]]): List[A] =\n    xss match\n      case List() => Nil\n      case x :: xs1 => append(x, flatten(xs1))\n\n  def mysum(xs: List[Int]): Int = xs.foldLeft(1)(_ + _)\n\n  def foldLeft[A, B](xs: List[A], e: B, f: (B, A) => B): B =\n    xs match \n      case List() => e\n      case x :: xs1 => foldLeft(xs1, f(e, x), f)\n  \n  def foldRight[A, B](xs: List[A], e: B, f: (A, B) => B): B =\n    xs match \n      case List() => e\n      case x :: xs1 => f(x, foldRight(xs1, e, f))\n\n  def fkh(s : String, n : Int) : String = s + \"[\" + n + \"]\"\n\n  def fkh2(n : Int, s : String) : String = s + \"[\" + n + \"]\"\n\n  def joinTerminateRight(xs: List[String], term: String): String =\n    foldRight(xs, \"\", (_+term+_))\n\n  def joinTerminateLeft(xs: List[String], term: String): String =\n    foldLeft(xs, \"\", (_+_+term))\n\n  // def plusTerm(a: String, term: String) = a + term\n  def plusTerm(a: String, t: String) : String = a + t\n\n  def testFun(a: String, b: String): String = a + b + \";\"\n\n\n  def firstNumGreaterThan(a: Int, xs: List[Int]): Int =\n    xs match \n      case List() => throw java.util.NoSuchElementException()\n      case x :: xs1 => \n        if x >= a then x\n        else firstNumGreaterThan(a, xs1)\n\n  // def firstIndexNumGreaterThan(a: Int, xs: List[Int]): Int =\n  //   xs.indexOf(firstNumGreaterThan(a, xs))\n\n  // def g[X, Y] (xs: List[X], f: List[X]=>List[Y]) : List[Y] = {\n  //   xs match\n  //     case Niil => Nil\n  //     case y::ys => f(y) :: g(ys, f)\n  // }\n  // def g[X, Y] (xs: List[X], f: X=>Y) : List[Y] = {\n  //   xs match\n  //     case Niil => Nil\n  //     case y::ys => f(y) :: g(ys, f)\n  // }\n\n  def ffff[X] (xss: List[List[X]]): List[X] = \n    for (xs <- xss; x <- xs) yield x\n\n\n  // def firstIndexNumGreaterThan(a: Int, xs: List[Int]): Int =\n  //   xs match \n  //     case List() => throw java.util.NoSuchElementException()\n  //     case x :: xs1 => \n  //       if x >= a then xs.indexOf(x)\n  //       else firstIndexNumGreaterThan(a, xs1)\n\n  // def hahahaha(xs: List[String]): List[String] = xs.foldLeft(\"\")(_ + _)\n\n  def member(a: Int, xs: List[Int]): Boolean =\n    xs match\n      case List() => false\n      case x::xs1 => \n        if x == a then true\n        else member(a, xs1)\n\n  def stringLengths(xs: List[String]): List[(String, Int)] =\n    xs.map(str => (str, str.length))\n\n  def delete1[X](x: X, ys: List[X]): List[X] =\n    ys match \n      case List() => ys\n      case y::ys1 => \n        if x == y then delete1(x, ys1)\n        else y::delete1(x, ys1)\n\n  def delete2[X](x: X, ys: List[X]): List[X] =\n    for y <- ys\n      if x != y yield y\n\n  def delete3[X](x: X, ys: List[X]): List[X] =\n    ys.filter(str => x != str)\n\n  def removeDupes1[X](xs: List[X]): List[X] =\n    xs match \n      case Nil => xs\n      case x:: Nil => xs\n      case x::xs1 => \n        if x == xs1.head then removeDupes1(xs1)\n        else x::removeDupes1(xs1)\n\n  def removeDupes3[X](count: Int, xs: List[X]): List[Int] =\n    xs match \n      case Nil => List(0)\n      case x:: Nil => List(count)\n      case x::xs1 => \n        if x == xs1.head then removeDupes3(count+1, xs1)\n        else count::removeDupes3(1, xs1)\n\n  def removeDupes2[X](xs: List[X]): List[(Int, X)] =\n    def removeDupes2_aux[X](count: Int, xs: List[X]): List[Int] =\n      xs match \n        case Nil => List(0)\n        case x:: Nil => List(count)\n        case x::xs1 => \n          if x == xs1.head then removeDupes2_aux(count+1, xs1)\n          else count::removeDupes2_aux(1, xs1)\n    \n    removeDupes2_aux(1, xs).zip(removeDupes1(xs))\n\n  def allDistinct(xs: List[Int]): Boolean =\n    xs match \n      case List() => true\n      case x::xs1 => \n        if member(x, xs1) == true then false\n        else allDistinct(xs1)\n\n  def f [X,Y] (a:Option[X], g:X=>Y) : Option[Y] = {\n    a match {\n      case None     => None\n      case Some (x) => Some (g (x))\n    }\n  }\n\n  def index [X] (xs:List[X], n:Int) : Option[X] = {\n    xs match {\n      case Nil               => None\n        case y::ys if (n == 0) => Some (y)\n      case _::ys             => index (ys, n - 1)\n    }\n  }\n\n  @tailrec    \n  def f [X] (xs:List[X], ys:List[X]) : List[X] = {\n    xs match {\n      case Nil   => ys\n      case z::zs => f (zs, z::ys)\n    }\n  }\n\n  enum Result[+X,+Y]:                                                                                   \n    case Ok(n:X)\n    case Error(s:Y) \n  import Result.*\n\n  def combine[U,X,Y] (us:List[U], f:U=>Result[X,Y]) : Result[List[X],List[Y]] = \n  us match \n    case Nil   => Ok (Nil)\n    case v::vs =>\n      (f (v), combine (vs, f)) match \n        case (Error (s), Error (ss)) => Error (s::ss)\n        case (Ok    (n), Error (ss)) => Error (ss)\n        case (Error (s), Ok    (ns)) => Error (List (s))\n        case (Ok    (n), Ok    (ns)) => Ok (n::ns)\n\n  def splitAt[X](n: Int, xs: List[X]): (List[X], List[X]) =\n    (n, xs) match\n      case(_, Nil) => (Nil, Nil)\n      case (-1, xs) => (List(), xs)\n      case (n, x::xs) => \n        val(la, lb) = splitAt(n-1, xs) \n        if(n > 0) then (x::la, lb) \n        else (la, x::lb)\n\n  def allEqual(xs: List[Int]): Boolean =\n    xs match\n      case Nil => true\n      case _::Nil => true\n      case x::xs1 =>\n        if x != xs1.head then false\n        else allEqual(xs1)\n\n  def test1[x] (xs: List[x]) : List[x] = \n    xs match\n      case Nil => xs\n      case y::ys => y :: test1(ys)\n\n  // def foldr[A, B] (f:(A, B)=>B, e:B, xs: List[A]):B = \n  //   xs match \n  //     case Nil => e\n  //     case y :: ys => f(y, foldr(f, e, ys))\n\n  // def foo (s: String, t: String) = s + \",\" + t\n\n  // def test2[A](xss:List[List[A]]) = \n  //   for xs <- xss\n  //   if (xs.length > 0)\n  //     x <- xs.tail\n  //     yield x\n\n  def foo(xs:List[String]) : List[String] = xs match\n    case Nil => Nil\n    case y :: ys => bar(ys)\n  \n  def bar(xs:List[String]) : List[String] = xs match\n    case Nil => Nil\n    case y :: ys => y :: (foo(ys))\n\n  // def test3[X](xs:List[X]):List[X] = xs match\n  //   case Nil => Nil\n  //   case y :: ys => test3(ys) ::: List(y)\n\n  // def test4[A,B](xs:List[A],ys:List[B]):List[(A,B)] = \n  //   (xs, ys) match\n  //     case (Nil,Nil) => Nil\n  //     case (a :: as, b :: bs) => (a, b) :: test4(as, bs)\n\n  // def test5(x:List[Int],y:List[Int]) : List[Int] = x ::: y\n\n  def test6 (fs: List[List[Int] => Int]) : List[Int] = \n    fs.map((f)=> f(List(1,2,3,4)))\n\n  def aa[X](xs:List[X]) : List[X] = \n    xs match\n      case Nil => Nil\n      case y :: ys => aa(ys) ::: List(y)\n  \n  def bb[X](xs:List[X],ys:List[X]) : List[X] = \n    xs match\n      case Nil => ys\n      case z :: zs => bb(zs, z::ys)\n  \n\n  // enum T:\n  //   case L\n  //   case N(v:Int, l:T, r:T)\n\n  // def test7(t:T):Int = t match\n  //   case L => 0\n  //   case N(v,l,r) => (test7(l)-test7(r)) + v\n\n\n  def test9(xs:List[Int], ys:List[Int]) : List[Int] = \n    def add(x:Int, y: Int) = x + y\n    (xs, ys) match\n      case (Nil,Nil) => Nil\n      case (a::b, c::d) => add(a, d) :: (test9(b, c))\n\n\n  @main def mmm() = \n  //List(a, b, c).foldLeft(z)(op) equals op(op(op(z, a), b), c)\n    println(\"-------\")\n    // val a = test1(List(1, 2, 3))\n    // val a = 5 :: 6 :: 7 :: Nil\n    // val a = List(1, 2) :: List(3, 4, 5) :: Nil\n    // val a = foldr(foo, \"\", List(\"the\", \"rain\", \"in\", \"spain\"))\n    // val a = test2(List(List(0,1,2),List(),List(3,4),List(5)))\n    // val a = foo(List(\"the\",\"rain\",\"in\",\"spain\"))\n    // val list = List(List(0,1,2),List(3,4,5),List(6,7,8))\n    // val a = list.map(x => x.reverse)\n    // val a = test3(List(1,9,5))\n    // val a = test4(List(1,2),List(('a',6),('b',7)))\n    // val us = List(1,2,3)\n    // val vs = List(4,5,6)\n    // val a1 = bb(us,vs)\n    // val a2 = bb(vs,us)\n    // val a = ()\n    // println(a1)\n    // println(a2)\n\n     // 1 2\n    // val a = List(List(1), List(2), List(3))\n    // val re = ffff(a)\n    // println(re)\n    // val a = test7( N(5,\n    //                 N(6,\n    //                   N(3,L,L),\n    //                   N(2,L,L),\n    //                 N(4,L,L)))\n    val a = test9(List(1,2),List(3,4))\n    println(a)\n\n    // val a = member (3, List (4, 6, 8, 5))\n\n    // val test = List(\"One Fish\", \"Two Fish\", \"Red Fish\", \"Blue Fish\")\n    // val a = test.map(noun => noun.length)\n\n    // val a = stringLengths(List(\"the\", \"rain\"))\n    // val a = delete3 (\"the\", List (\"the\",\"the\",\"was\",\"a\",\"product\",\"of\",\"the\",\"1980s\"))\n    //List (1,2,3,4,5,6,7,8,9,2,9)\n    //((2,1),(1,2),(3,3),(2,4),(1,5),(1,6),(2,7),(1,8),(1,9),(3,2),(1,9))\n    // val a = removeDupes2 (List (1,1,2,3,3,3,4,4,5,6,7,7,8,9,2,2,2,9))\n    // val a = allDistinct (List (1,2,3,2,4,5))\n    // val a = f (index (List (10, 11, 12), 1), (n:Int) => n * 2)\n    // val a = f (index (List (10, 11, 12), 5), (n:Int) => n * 2)\n    // val a = combine (List(1,2,3), (n:Int) => if (n%2==0) Ok (n) else Error (n))\n    // val a = combine (List(0,2,4), (n:Int) => if (n%2==0) Ok (n) else Error (n))\n    // val a = splitAt(3,List(1,11,21,31,41,51))\n\n    // val a = allEqual (List (5))\n    // println(a)\n\n    // val a = List(2, 1, 3, 2, 1, 1, 2, 1, 1, 3, 1)\n\n    // val p1 = List(\"a\", \"b\")\n    // val p2 = List(3, 4)\n    // val p3 = p1.zip(p2)\n    // val p4 = p1::p2::Nil\n    // val a = List(1, 2, 3)\n    // val b = 4::a\n    // println(b)\n    // println(p4)\n    // println(p3)\n\n    // val a = \"a\"\n    // val b = List()\n    // val c = b :+ a\n    // println(c)\n\n    // val b = List(1, 2, 3)\n    // val c = 4\n    // val d = c::b\n    // println(d)\n\n    // val xs = List(\"a\", \"b\", \"c\", \"d\")\n    // val a = foldLeft(xs, \"\", testFun)\n    // val a = joinTerminateLeft(xs, \";\")\n    // val a = joinTerminateRight(xs, \";\")\n    // val a = hahahaha(xs)\n\n    // val b = xs.foldLeft(\"\")(_+_+\";\")\n    // println(s\"b:$b\")\n\n    // val xs = List(1, 2, 3, 4, 5, 3)\n    // val a = firstIndexNumGreaterThan(2, xs)\n    // val a = firstNumGreaterThan(2, xs)\n    // val a = foldLeft(xs, \"@\", fkh)\n    // val ys = List(6, 7, 8)\n    // val a = map(xs, (x) => x+1)\n    // val a = myfilter(xs, _ > 2)\n    // val a = append(xs, ys)\n    // val a = xs.head :: ys\n    // val a = List(xs, ys)\n    // val b = flatten(a)\n    // println(a)\n    // println(b)\n    // val a = mysum(ys)\n    // val a = foldLeft(xs, \"@\", fangkuohao)\n    // val a = xs.init\n    // val a = foldRight(xs, \"@\", fangkuohao2)\n    // val a = foldRight(xs.reverse, \"@\", plusTerm)\n    // val a = joinTerminateRight(xs, \";\")\n    // val a = foldLeft(xs, \"@\", plusTerm)\n    // println(a)\n\n\n\n    // val a = List.range(1, 5).flatMap(\n    //           i => List.range(1, i).map(\n    //             j => (i, j)\n    //           )\n    //         )\n    // println(a)\n    // val multiplication = List.tabulate(5,5)(_ * _)\n    // println(multiplication)\n\n    // val a = (List(10, 20).zip(List(3, 4, 5)))\n    // val a = (List(\"abc\", \"de\").lazyZip(List(3, 2))).forall(_.length == _)\n    // println(a)\n\n\n    // val l1 = List(1, 2, 3)\n    // val l2 = List(4, 5, 6)\n    // val l1 = List(\"audi\", \"bmw\", \"mercedes\")\n    // val l2 = List(\"honda\", \"toyota\", \"mazada\")\n    // val l3 = l1::l2::Nil\n    // println(l3)\n    // val l4 = l3.flatten\n    // println(l4)\n\n    // val xs = List(1,2,3,4,5)\n    // val xs = List(\"audi\", \"bmw\", \"mercedes\", \"honda\", \"toyota\")\n    // println(xs.reverse.init)\n    // println(xs.tail.reverse)\n    // println(xs.splitAt(3))\n    // println(xs.take(3))\n    // println(xs.drop(2))\n    // println(\"head: \" + xs.head)\n    // println(\"tail: \" + xs.tail)\n    // println(\"init: \" + xs.init)\n    // println(\"last: \" + xs.last)\n    // println(xs.apply(1))\n    // println(xs.indices)\n    // println(xs.indices.zip(xs))\n    // println(xs.zipWithIndex.unzip.last)\n    // println(xs)\n    // println(xs.toString)\n    // println(xs.mkString)\n\n    // val abcde = List('a', 'b', 'c', 'd', 'e')\n    // val abcde = List(\"a\",\"b\",\"c\",\"d\",\"e\")\n    // val zipped = abcde.zip(List(1, 2, 3))\n    // println(zipped)\n\n    // val list = List(8, 6)\n    // val sorted = isort(list)\n    // println(sorted)\n    \n    // val emptyList = List(1)\n    // println(emptyList.head)\n    // println(emptyList.tail)\n\n    // println(twice(_ + 1, 10))\n\n    // printMultiTable()\n\n    // val list = List(1,2,3,4,5)\n    // println(list.exists(_ < 2))\n    // list.foreach(x => \n    //   println(x)\n    // )\n    // list.foreach((x: Int) => \n    //   println(x)\n    // )\n    // val list2 = list.filter(x =>\n    //   x > 3\n    // )\n    // val list2 = list.filter(\n    //   _ > 3\n    // )\n    // println(list2)\n    \n    // val re = gcdLoop(17, 8)\n    // println(re)\n\n    // var line = scala.io.StdIn.readLine()\n\n    // var array = List(2, 5, 1, 2, 3)\n    // val a0 = array(0)\n    // println(a0)\n    // a0 match\n    //   case 1 =>\n    //     println(\"is 111\")\n    //   case 2 =>\n    //     println(\"is 222\")\n    //   case 3 =>\n    //     println(\"is 333\")\n    //   case _ =>\n    //     println(\"is ---\")\n    \n    \n    // val str = \n    // a0 match\n    //   case 1 => \"one\"\n    //   case 2 => \"two\"\n    //   case 3 => \"three\"\n    //   case _ => \"default\"\n    // println(s\"str: $str\")\n\n\n\n    // while (line = scala.io.StdIn.readLine()) != \"\" do\n    //   println(s\"Read: $line\")\n\n    // while\n    //   val line = readLine()\n    //   println(s\"Read: $line\")\n    //   line != \"!\"\n    // do ()\n\n    // val result = sumTail(List.empty)\n    // val result = maxTail(List.empty)\n    // println(s\"result: $result\")\n\n    // val list = List(100, 32, 345, 774, 105)\n    // val b = max(list)\n    // println(s\"b: $b\")\n\n    // val countList = otpu(5, -3)\n    // println(countList)\n\n    // println(\"\"\"|welcome to chicago 3000.\n    //            |type \"help\" for help.\"\"\".stripMargin)\n    // println(f\"${math.Pi}%.5f\")\n\n    // val aa = f\"$pi is approximately ${math.Pi}%.8f.\"\n    // println(aa)\n\n    // var str = \"\\\\\\\\'\"\n    // var str = raw\"\\\\\\\\'\"\n    // println(str)\n\n\n    // val num = factLog(3)\n    // println(\"num is \" + num)\n\n    // val factTest: Int = factLog(5)\n    // println(\"factTest is \" + factTest)\n    // val factTest: List[Int] =\n    //   List(fact(1), fact(2), fact(3), fact(4), fact(5))\n    // println(\"factTest : \" + factTest)\n    // val n = 6\n    // val result = fib(n)\n    // println(\"num : \" + n + \" result : \" + result)\n\n    // val ll = List.empty\n    // val result = sum(ll)\n    // println(\"result : \" + result)\n    \n    // val pair = (44, \"Lewis\")\n    // val num = pair(0)\n    // val name = pair(1)\n    // println(s\"num: $num - name: $name\")\n\n    // pair(3) = 33\n    // pair(4) = \"Max\"\n    // val num2 = pair(3)\n    // val name2 = pair(4)\n    // println(s\"num2: $num2 - name2: $name2\")\n\n    // var jet = Set(\"Boeing\", \"Airbus\")\n    // jet += \"CAAC\"\n    // println(s\"jet: $jet\")\n\n    // var mutSet = mutable.Set(\"a\", \"b\")\n    // mutSet += \"c\"\n    \n    // scala    swift\n    // array    mutablearray\n    // list     immutablearray\n    // turple   turple\n    // set      set\n    // map      dictionary\n\n    // val map1 = mutable.Map.empty[Int, String]\n    // map1 += (1 -> \"a\")\n    // map1.+=(2 -> \"b\")\n    // map1.update(3, \"c\")\n    // println(s\"map1: $map1\")\n    // println(\"map1(2): \" + map1(2))\n\n    // val map2 = Map(\n    //   \"a\" -> 1,\n    //   \"b\" -> 2,\n    //   \"c\" -> 3\n    // )\n    // println(s\"map2: $map2\")\n    // println(\"map2(\\\"c\\\"): \" + map2(\"c\"))\n\n  //  val list = List(\"hello\", \"qilu\", \"Lewis\")\n  //  val list2 = formatArgs(list)\n  //  println(list2)\n\n  //  val brand = List(\"audi\", \"bmw\", \"mercedes\")\n  //  val newStr = brand.map(element => element + \" car\")\n  //  println(s\"newStr: $newStr\")\n\n  //  val str2 = \n  //    for ele <- brand yield\n  //      ele + \" car\"\n  //  println(s\"str2: $str2\")\n\n  //  val ques = Vector(\"Who\", \"What\", \"When\", \"Where\", \"Why\")\n  //  val usingMap = ques.map(e => e.toLowerCase + \"?\")\n  //  val usingYield = \n  //    for e <- ques yield\n  //      e.toLowerCase + \"?\"\n  //  println(s\"usingMap: $usingMap\")\n  //  println(s\"usingYield: $usingYield\")\n\n  //  val startsW = ques.find(q => q.startsWith(\"W\"))\n  //  val startsH = ques.find(q => q.startsWith(\"H\"))\n  //  val endso = ques.find(q => q.endsWith(\"o\"))\n  //  val hasLen4 = ques.find(q => q.length == 4)\n  //  val hasLen5 = ques.find(q => q.length == 5)\n\n  //  println(s\"startsW: $startsW\")\n  //  println(s\"startsH: $startsH\")\n  //  println(s\"endso: $endso\")\n  //  println(s\"hasLen4: $hasLen4\")\n  //  println(s\"hasLen5: $hasLen5\")\n\n  //  val newstr = startsW.map(s => s.toUpperCase)\n  //  println(\"newstr: \" + newstr)\n\n  //  val newstr2 = startsH.map(s => s.toUpperCase)\n  //  println(\"newstr2: \" + newstr2)\n    // val a = -2.0\n    // val a = (2.0).unary_-\n    // println(a)\n\n    // val str1 = \"Hello World!\"\n    // val str2 = str1 toLowerCase\n    // println(s\"str1: $str1\")\n    // println(s\"str2: $str2\")\n    // println(1==1.0f)\n    // for i <- 1 until 10 do\n    //   println(i)\n    // val filesHere = (new java.io.File(\".\")).listFiles\n    // for file <- filesHere do\n    //   println(file)\n\n    // for file <- filesHere\n    //   if file.isFile\n    //   if file.getName.endsWith(\".scala\") do\n    //     println(file)\n    // val forLineLengths =\n    //   for\n    //     file <- filesHere\n    //     if file.getName.endsWith(\".scala\")\n    //     line <- fileLines(file)\n    //     trimmed = line.trim\n    //     if trimmed.matches(\".*for.*\")\n    //   yield trimmed.length\n    // println(s\"forLineLengths : $forLineLengths\")\n\n    // val a = {var x=1; x = x + 1; x} * {var x = 1; x = x + 1; x}\n    // println(a)\n    // val a = List(List(1,2,3),List(4,5,6))\n    // val a = (1::2::3::Nil).reverse\n    // val a = (1::2::3::Nil) ::: (4::5::6::Nil)\n    // println(a)\n\n  "}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/storage.scala","languageId":"scala","version":1,"text":"  // GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add code\n * immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n *\n * GRADING\n *\n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and\n *    tests with no compilation errors.  Submissions with compilation errors\n *    will receive 0 points.  Note that refactoring the code will cause the\n *    tests to fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your\n *    submission will result in 0 points for this assignment.\n *\n * 3. You MAY use (re)assignment to variables and \"val\" and \"var\"\n *    declarations (you will have to).\n *\n * 4. In all of the exercises in this file, you can only add code between the\n *    existing \"{...}\" for the val/def.  That is, you cannot add a new\n *    val/def directly inside the \"storage\" object.\n *\n * SUBMISSION\n *\n * 1. Submit this file on D2L before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be\n *    discussed in class.\n *\n */\n\nobject storage:\n\n  // EXERCISE 1: Complete the following definition, so that \"constant5\" is a\n  // function that returns 5 whenever it is invoked.\n  val constant5: () => Int =\n      // TODO: Complete the definition.\n      () => throw UnsupportedOperationException()\n\n  // EXERCISE 2: Complete the following definition, so that \"constant\" is a\n  // function that when invoked with integer n returns a function that\n  // returns n whenever it is invoked.\n  val constant: Int => () => Int =\n        // TODO: Complete the definition.\n        (n: Int) => throw UnsupportedOperationException()\n\n  // EXERCISE 3: Complete the following definition, so that \"counter0\" is a\n  // (stateful) function that returns 0 when it is first invoked, then 1,\n  // then 2, etc.\n  //\n  // REMEMBER: you can use \"var\" but everything you add has to be inside the\n  // \"{...}\" body of \"counter0\".\n\n  // This rule applies throughout this assignment.\n  val counter0: () => Int =\n    // TODO: Complete the definition.\n    () => throw UnsupportedOperationException()\n\n  // EXERCISE 4: Complete the following definition, so that \"counter\" is a\n  // (stateless) function that when invoked with integer n returns a\n  // (stateful) function that returns n when it is first invoked, then n+1,\n  // then n+2, etc.\n  //\n  // The counters must be independent, i.e., running \"counter (0)\" twice\n  // should yield two functions that do not interfere with one another's\n  // state.\n  val counter: Int => () => Int =\n    // TODO: Complete the definition.\n    (n: Int) => throw UnsupportedOperationException()\n\n  // EXERCISE 5: Complete the following definition, so that \"getAndSet\" is a\n  // (stateless) function that when invoked with integer n returns a pair of\n  // functions (that share state) that allow reading and writing a var that\n  // is initialized with integer n.\n  //\n  // The first function in the pair should be the reader.  The second\n  // function in the pair should be the writer.\n  //\n  // For example, the following expression should return 10:\n  // { val (get, set) = getAndSet (5); set (10); get () }\n  //\n  // Multiple calls to \"getAndSet\" should yield independent pairs, i.e., the\n  // first pair returned should not share any state with the second pair\n  // returned.\n  val getAndSet: Int => (() => Int, Int => Unit) =\n    // TODO: Complete the definition.\n    (n: Int) => throw UnsupportedOperationException()\n\n  // EXERCISE 6: Complete the following definition, so that \"getAndSetSpy\" is\n  // a (stateful) function that when invoked it returns a pair.\n  //\n  // The second component of the pair should behave like \"getAndSet\" above\n  // (with the exception noted next).\n  //\n  // The first component of the pair is a function that, when invoked,\n  // returns the total number of times that a \"set\" call has been made.\n  //\n  // That number should cover all calls to \"set\" made in all pairs created\n  // via \"getAndSetSpy\".  That is, the total number is a piece of state\n  // shared all \"set\" functions created via \"getAndSetSpy\".\n  //\n  // For example:\n  // val (spy1, getAndSet1) = getAndSetSpy ()\n  // val (spy2, getAndSet2) = getAndSetSpy ()\n  // val (get1a, set1a) = getAndSet1 (0)\n  // val (get2a, set2a) = getAndSet2 (0)\n  // set1a(10)\n  // set2a(20)\n  // spy1()\n  //   val res1: Int = 2\n  //\n  // The result is 2, not 1.\n  //\n  val getAndSetSpy: () => (() => Int, Int => (() => Int, Int => Unit)) =\n    // TODO: Complete the definition.\n    () => throw UnsupportedOperationException()\n\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@7db47323, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/Users/qilu/Documents/Git_Code/CSC447/hw/target/scala-3.0.1/zinc/inc_compile_3.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Oct 17, 2021, 3:03:23 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/qilu/Library/Mobile%20Documents/com~apple~CloudDocs/Documents/Class/CSC%20447/Quiz%E7%AD%94%E6%A1%88/CSC-447-Concepts-of-Programming-Languages-master/storage.scala","languageId":"scala","version":1,"text":"// GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add\n * code immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n * \n * GRADING\n * \n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and tests with no\n *    compilation errors.  Submissions with compilation errors will receive 0 points.\n *    Note that refactoring the code will cause the tests to fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your submission will\n *    result in 0 points for this assignment.\n *\n * 3. You MAY use (re)assignment to variables and \"val\" and \"var\" declarations (you will have to).\n *\n * 4. In all of the exercises in this file, you can only add code between the\n *    existing \"{...}\" for the val/def.  That is, you cannot add a new val/def directly\n *    inside the \"storage\" object.\n *\n * SUBMISSION\n *\n * 1. Push your local repository to the repository created for you on Bitbucket before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be discussed in class.\n * \n */\n\n\nobject storage {\n\n  // EXERCISE 1: Complete the following definition, so that \"constant5\" is a function that returns 5\n  // whenever it is invoked.\n  val constant5 : () => Int = {\n    () => 5\n  }\n\n  // EXERCISE 2: Complete the following definition, so that \"constant\" is a function that when\n  // invoked with integer n returns a function that returns n whenever it is invoked.\n  val constant : Int => () => Int = {\n    (n: Int) =>(() => n)\n  }\n\n  // EXERCISE 3: Complete the following definition, so that \"counter0\" is a (stateful) function that\n  // returns 0 when it is first invoked, then 1, then 2, etc.  \n  // REMEMBER: you can use \"var\" but everything you add has to be inside the \"{...}\" body of \"counter0\".\n  // This rule applies throughout this assignment.\n  val counter0 : () => Int = {\n    var n = -1\n\t() => {n += 1\n\tn}\n  }\n\n  // EXERCISE 4: Complete the following definition, so that \"counter\" is a (stateless) function that\n  // when invoked with integer n returns a (stateful) function that returns n when it is first\n  // invoked, then n+1, then n+2, etc.  The counters must be independent, i.e., running \"counter (0)\" \n  // twice should yield two functions that do not interfere with one another's state.\n  val counter : Int => () => Int = {\n    \n\t(n: Int) => {\n\tvar cn = n-1\n\t() => \n\t{\n\tcn = cn + 1\n\tcn\n\t}\n  }\n  }\n\n  // EXERCISE 5: Complete the following definition, so that \"getAndSet\" is a (stateless) function\n  // that when invoked with integer n returns a pair of functions (that share state) that allow\n  // reading and writing a var that is initialized with integer n.  The first function in the pair\n  // should be the reader.  The second function in the pair should be the writer.  For example, the\n  // following expression should return 10: { val (get, set) = getAndSet (5); set (10); get () } \n  // Multiple calls to \"getAndSet\" should yield independent pairs, i.e., the first pair returned \n  // should not share any state with the second pair returned.\n  val getAndSet : Int => (() => Int, Int => Unit) = {\n    (n:Int) => {\n\tvar param = n \n\tdef get: () => Int = () => param\n\tdef set: Int => Unit = (m:Int) => param = m\n\t(get,set)\n\t}\n  }\n\n  // EXERCISE 6: Complete the following definition, so that \"getAndSetSpy\" is a (stateful) function\n  // that when invoked it returns a pair.  The second component of the pair should behave like\n  // \"getAndSet\" above (with the exception noted next).  The first component of the pair is a\n  // function that, when invoked, returns the total number of times that a \"set\" call has been made.\n  // That number should cover all calls to \"set\" made in all pairs created via \"getAndSetSpy\".  That is, \n  // the total number is a piece of state shared all \"set\" functions created via \"getAndSetSpy\".\n  val getAndSetSpy : () => (() => Int, Int => (() => Int, Int => Unit)) = {\n    ()=>{\n\tvar count = 0\n\tval getSetCount: Int => (() => Int, Int => Unit) = {\n\t(n:Int) => {\n\tvar param = n \n\tdef get: () => Int = () => param\n\tdef set: Int => Unit = (m:Int) =>{count = count + 1; param = m}\n\t(get,set)\n\t}\n  }\n  var getCount: () => Int = () => count\n  var getSpy: Int => (() => Int, Int => Unit) = getSetCount\n  (getCount,getSpy)\n  }\n  }\n\n}\n\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///Users/qilu/Library/Mobile%20Documents/com~apple~CloudDocs/Documents/Class/CSC%20447/Quiz%E7%AD%94%E6%A1%88/CSC-447-Concepts-of-Programming-Languages-master/storage.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, ♨1, shutdown, null})[0m
