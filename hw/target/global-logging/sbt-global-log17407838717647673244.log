[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/play/README.scala","languageId":"scala","version":1,"text":"// The src directory is meant for code that will be run with automated tests.\n// Put other code in this directory.\n//\n// sbt requires that all files in src/main/scala must compile.\n// That can be a pain when you want to experiment.\n//\n// In the scala console, you can load this file by typing\n//    scala> :load play/README.scala\n//    scala> length1(xs)\n//\n\n/*\nval xs = List(11, 21, 31)\nval xss = List(List(11, 21), List(), List(31), List(41, 51, 61))\n\ndef log[X](prefix: String, d: Int = 0)(computeResult: => X) =\n  val indent = \"  \" * d\n  println(s\"${indent}${prefix}\")\n  val result = computeResult\n  println(s\"${indent}${prefix} : ${result}\")\n  result\n\n*/\n\n// This is the length function from the first lecture on scala, with logging\n// This version is right recursive, computing the operator with the RESULT of\n// recursive call.\n\n/*\ndef length1[X](xs: List[X]): Int =\nlog(s\"length($xs)\") {\n  xs match\n    case Nil     => 0\n    case _ :: ys => 1 + length1(ys)\n}\n\n*/\n\n// Here is a version that recurs into the parameter instead of the result. This\n// version is left recursive, AKA tail recursive, computing the operator into a\n// PARAMETER of the recursive call.\n//\n// This version also uses the optional parameter d to indicate the call depth.\n\n/*\ndef length2[X](xs: List[X], accumulator: Int = 0, d: Int = 0): Int =\n  log(s\"length($xs, $accumulator)\", d) {\n    xs match\n      case Nil     => accumulator\n      case _ :: ys => length2(ys, 1 + accumulator, d + 1)\n  }\n\n  */\n\n// Try this:\n//    scala> :load play/README.scala\n//    scala> length1(xs)\n//    scala> length2(xs)\n// Try changing length1 to use a depth parameter for indentation.\n\n// @main def m() = \n//   println(\"hello world\")\n\n// @main def m(args: String*) = \n//   println(\"hello, \" + args(0) + \"!\")\n\n// @main def m(name: String) = \n//   println(\"hello, \" + name + \"!\")\n\n// @main def m(name: String*) = \n//   var i = 0\n//   while i < name.length do\n//     println(name(i))\n//     i += 1\n\n// @main def m(name: String*) = \n//   var i = 0\n//   while i < name.length do\n//     if i!= 0 then\n//       print(\" \")\n//     print(name(i))\n//     i += 1\n//   println()\n\n// @main def m(args: String*) = \n//   args.foreach((a: String) => println(a))\n\n// @main def m(args: String*) = \n//   args.foreach(println)\n\n// @main def m(args: String*) = \n//   for a <- args do\n//     println(a)\n\n// var big = new java.math.BigInteger(\"123\")\n\n// @main def fun() = \n//   val greetStr = new Array[String](3)\n//   greetStr(0) = \"qilu\"\n//   greetStr(1) = \"is\"\n//   greetStr(2) = \"p1\"\n//   for i <- 0 to 2 do\n//     println(greetStr(i))\n\n//   for a <- greetStr do\n//     println(a)\n\n//   greetStr.foreach(str => println(str))\n\n// @main def fun() = \n//   val greetStr = new Array[String](3)\n//   greetStr.update(0, \"qilu\")\n//   greetStr.update(1, \"is\")\n//   greetStr.update(2, \"p1\")\n//   for i <- 0.to(2) do\n//     println(greetStr(i))\n\n// @main def fun() = \n//   val l1 = List(1, 2)\n//   val l2 = List(3, 4)\n//   val l3 = l1 ::: l2\n//   val l4 = List(2, 3)\n//   val l5 = 1 :: l4\n//   val l6 = 1 :: 2 :: 3 :: 4 :: 5 :: Nil\n//   println(\"l1 is \" + l1)\n//   println(\"l2 is \" + l2)\n//   println(\"l3 is \" + l3)\n//   println(\"l4 is \" + l4)\n//   println(\"l5 is \" + l5)\n//   println(\"l6 is \" + l6)\n\nimport java.util.NoSuchElementException\nimport scala.collection.mutable\nimport scala.collection.immutable\nimport scala.compiletime.ops.int\nimport scala.language.postfixOps\nimport scala.io.StdIn.readLine\n\nobject test66:\n\n  def log[X](prefix: String)(computeResult: => X) =\n    println(prefix)\n    val result = computeResult\n    println(s\"prefix $prefix : rs $result\")\n    result\n\n  def fact(n: Int): Int =\n    if n <= 1 then 1\n    else n * fact(n - 1)\n\n  def factLog(n: Int): Int =\n    log(s\"fact($n)\") {\n      if n <= 1 then 1\n      else n * factLog(n - 1)\n    }\n\n  def fib(n: Int): Int =\n  // TODO: Provide definition here.\n    if n < 0 then\n      throw UnsupportedOperationException()\n    if n == 0 || n == 1 then n\n    else fib(n-1) + fib(n-2)\n\n  def sum(xs: List[Int]) : Int =\n    if xs.isEmpty then throw UnsupportedOperationException()\n    if xs.length == 1 then xs.head\n    else xs.head + sum(xs.tail)\n  \n  def max(xs: List[Int]): Int =\n    if xs.isEmpty then throw java.util.NoSuchElementException()\n    if xs.length == 1 then xs.head\n    else (xs.head max max(xs.tail))\n\n  def otpu(start: Int, end: Int): List[Int] =\n    if start < end then Nil\n    else start :: otpu(start-1, end)\n\n  def formatArgs(args: List[String]) = args.mkString(\"\\n\")\n\n  def sumTailAux(xs: List[Int], accumulator: Int): Int =\n    xs match\n      case Nil     => accumulator\n      case y :: ys => sumTailAux(ys, accumulator + y)\n  \n  def sumTail(xs: List[Int]): Int =\n    if xs.isEmpty then throw UnsupportedOperationException()\n    else sumTailAux(xs.tail, xs.head)\n\n  def maxTailAux(xs: List[Int], accumulator: Int): Int =\n    if xs.length == 1 then (accumulator max xs.head)\n    else (accumulator max maxTailAux(xs.tail, xs.head))\n\n  def maxTail(xs: List[Int]): Int =\n    xs match\n      case Nil     => throw NoSuchElementException()\n      case y :: ys => maxTailAux(ys, y)\n\n  def ***() = \n    println(\"---\")\n\n  def fileLines(file: java.io.File) =\n    scala.io.Source.fromFile(file).getLines().toArray\n\n  def gcdLoop(x: Long, y: Long): Long =\n    var a = x\n    var b = y\n    while a != 0 do\n      val temp = a\n      a = b % a\n      b = temp\n      println(s\"---a:$a b:$b\")\n    b\n  \n  def printMultiTable() =\n    var i = 1\n    // only i in scope here\n    while i <= 10 do\n      var j = 1\n      // both i and j in scope here\n      while j <= 10 do\n        val prod = (i * j).toString\n        // i, j, and prod in scope here\n        var k = prod.length\n        // i, j, prod, and k in scope here\n        while k < 4 do\n          print(\" \")\n          k += 1\n        print(prod)\n        j += 1\n        // i and j still in scope; prod and k out of scope\n      println()\n      i += 1\n    // i still in scope; j, prod, and k out of scope\n\n  def twice(op: Double => Double, x: Double) = op(op(x))\n\n  def isort(xs: List[Int]): List[Int] =\n    if xs.isEmpty then Nil\n    else insert(xs.head, isort(xs.tail))\n\n  def insert(x: Int, xs: List[Int]): List[Int] =\n    if xs.isEmpty || x <= xs.head then x :: xs\n    else xs.head :: insert(x, xs.tail)\n\n  // def append[T](xs: List[T], ys: List[T]): List[T] =\n  //   xs match\n  //   case List() => ys\n  //   case x :: xs1 => x :: append(xs1, ys)\n    // case x :: xs1 => x :: xs1 :: ys\n\n\n  def map[A, B](xs: List[A], f: A => B): List[B] =\n    xs match\n      case List() => Nil\n      case x::xs1 => f(xs.head) :: map(xs.tail, f)\n  \n  def myfilter[A](xs: List[A], f: A => Boolean): List[A] =\n    xs match\n      case List() => Nil\n      case x::xs1 => \n        if f(xs.head) then xs.head :: myfilter(xs.tail, f)\n        else myfilter(xs.tail, f)\n\n  def append[A](xs: List[A], ys: List[A]): List[A] =\n    xs match\n      case List() => ys\n      case x :: xs1 => x :: append(xs1, ys)\n\n  // def myappend[A](xs: List[A], ys: List[A]): List[A] =\n  //   ys match\n  //     case List() => xs\n  //     case y::ys1 =>\n  //       val newlist[A] = xs:::ys.head\n  //       myappend(newlist, ys.tail)\n\n  def flatten[A](xss: List[List[A]]): List[A] =\n    xss match\n      case List() => Nil\n      case x :: xs1 => append(x, flatten(xs1))\n\n  def mysum(xs: List[Int]): Int = xs.foldLeft(1)(_ + _)\n\n  def foldLeft[A, B](xs: List[A], e: B, f: (B, A) => B): B =\n    xs match \n      case List() => e\n      case x :: xs1 => foldLeft(xs1, f(e, x), f)\n  \n  def foldRight[A, B](xs: List[A], e: B, f: (A, B) => B): B =\n    xs match \n      case List() => e\n      case x :: xs1 => f(x, foldRight(xs1, e, f))\n\n  def fkh(s : String, n : Int) : String = s + \"[\" + n + \"]\"\n\n  def fkh2(n : Int, s : String) : String = s + \"[\" + n + \"]\"\n\n  def joinTerminateRight(xs: List[String], term: String): String =\n    foldRight(xs, \"\", (_+term+_))\n\n  def joinTerminateLeft(xs: List[String], term: String): String =\n    foldLeft(xs, \"\", (_+_+term))\n\n  // def plusTerm(a: String, term: String) = a + term\n  def plusTerm(a: String, t: String) : String = a + t\n\n  def testFun(a: String, b: String): String = a + b + \";\"\n\n\n  def firstNumGreaterThan(a: Int, xs: List[Int]): Int =\n    xs match \n      case List() => throw java.util.NoSuchElementException()\n      case x :: xs1 => \n        if x >= a then x\n        else firstNumGreaterThan(a, xs1)\n\n  // def firstIndexNumGreaterThan(a: Int, xs: List[Int]): Int =\n  //   xs.indexOf(firstNumGreaterThan(a, xs))\n\n  // def g[X, Y] (xs: List[X], f: List[X]=>List[Y]) : List[Y] = {\n  //   xs match\n  //     case Niil => Nil\n  //     case y::ys => f(y) :: g(ys, f)\n  // }\n  // def g[X, Y] (xs: List[X], f: X=>Y) : List[Y] = {\n  //   xs match\n  //     case Niil => Nil\n  //     case y::ys => f(y) :: g(ys, f)\n  // }\n\n  def ffff[X] (xss: List[List[X]]): List[X] = \n    for (xs <- xss; x <- xs) yield x\n\n\n  // def firstIndexNumGreaterThan(a: Int, xs: List[Int]): Int =\n  //   xs match \n  //     case List() => throw java.util.NoSuchElementException()\n  //     case x :: xs1 => \n  //       if x >= a then xs.indexOf(x)\n  //       else firstIndexNumGreaterThan(a, xs1)\n\n  // def hahahaha(xs: List[String]): List[String] = xs.foldLeft(\"\")(_ + _)\n\n  @main def mmm() = \n  //List(a, b, c).foldLeft(z)(op) equals op(op(op(z, a), b), c)\n    println(\"-------\")\n\n    val a = List(List(1), List(2), List(3))\n    val re = ffff(a)\n    println(re)\n\n\n    // val xs = List(\"a\", \"b\", \"c\", \"d\")\n    // val a = foldLeft(xs, \"\", testFun)\n    // val a = joinTerminateLeft(xs, \";\")\n    // val a = joinTerminateRight(xs, \";\")\n    // val a = hahahaha(xs)\n\n    // val b = xs.foldLeft(\"\")(_+_+\";\")\n    // println(s\"b:$b\")\n\n    // val xs = List(1, 2, 3, 4, 5, 3)\n    // val a = firstIndexNumGreaterThan(2, xs)\n    // val a = firstNumGreaterThan(2, xs)\n    // val a = foldLeft(xs, \"@\", fkh)\n    // val ys = List(6, 7, 8)\n    // val a = map(xs, (x) => x+1)\n    // val a = myfilter(xs, _ > 2)\n    // val a = append(xs, ys)\n    // val a = xs.head :: ys\n    // val a = List(xs, ys)\n    // val b = flatten(a)\n    // println(a)\n    // println(b)\n    // val a = mysum(ys)\n    // val a = foldLeft(xs, \"@\", fangkuohao)\n    // val a = xs.init\n    // val a = foldRight(xs, \"@\", fangkuohao2)\n    // val a = foldRight(xs.reverse, \"@\", plusTerm)\n    // val a = joinTerminateRight(xs, \";\")\n    // val a = foldLeft(xs, \"@\", plusTerm)\n    // println(a)\n\n\n\n    // val a = List.range(1, 5).flatMap(\n    //           i => List.range(1, i).map(\n    //             j => (i, j)\n    //           )\n    //         )\n    // println(a)\n    // val multiplication = List.tabulate(5,5)(_ * _)\n    // println(multiplication)\n\n    // val a = (List(10, 20).zip(List(3, 4, 5)))\n    // val a = (List(\"abc\", \"de\").lazyZip(List(3, 2))).forall(_.length == _)\n    // println(a)\n\n\n    // val l1 = List(1, 2, 3)\n    // val l2 = List(4, 5, 6)\n    // val l1 = List(\"audi\", \"bmw\", \"mercedes\")\n    // val l2 = List(\"honda\", \"toyota\", \"mazada\")\n    // val l3 = l1::l2::Nil\n    // println(l3)\n    // val l4 = l3.flatten\n    // println(l4)\n\n    // val xs = List(1,2,3,4,5)\n    // val xs = List(\"audi\", \"bmw\", \"mercedes\", \"honda\", \"toyota\")\n    // println(xs.reverse.init)\n    // println(xs.tail.reverse)\n    // println(xs.splitAt(3))\n    // println(xs.take(3))\n    // println(xs.drop(2))\n    // println(\"head: \" + xs.head)\n    // println(\"tail: \" + xs.tail)\n    // println(\"init: \" + xs.init)\n    // println(\"last: \" + xs.last)\n    // println(xs.apply(1))\n    // println(xs.indices)\n    // println(xs.indices.zip(xs))\n    // println(xs.zipWithIndex.unzip.last)\n    // println(xs)\n    // println(xs.toString)\n    // println(xs.mkString)\n\n    // val abcde = List('a', 'b', 'c', 'd', 'e')\n    // val abcde = List(\"a\",\"b\",\"c\",\"d\",\"e\")\n    // val zipped = abcde.zip(List(1, 2, 3))\n    // println(zipped)\n\n    // val list = List(8, 6)\n    // val sorted = isort(list)\n    // println(sorted)\n    \n    // val emptyList = List(1)\n    // println(emptyList.head)\n    // println(emptyList.tail)\n\n    // println(twice(_ + 1, 10))\n\n    // printMultiTable()\n\n    // val list = List(1,2,3,4,5)\n    // println(list.exists(_ < 2))\n    // list.foreach(x => \n    //   println(x)\n    // )\n    // list.foreach((x: Int) => \n    //   println(x)\n    // )\n    // val list2 = list.filter(x =>\n    //   x > 3\n    // )\n    // val list2 = list.filter(\n    //   _ > 3\n    // )\n    // println(list2)\n    \n    // val re = gcdLoop(17, 8)\n    // println(re)\n\n    // var line = scala.io.StdIn.readLine()\n\n    // var array = List(2, 5, 1, 2, 3)\n    // val a0 = array(0)\n    // println(a0)\n    // a0 match\n    //   case 1 =>\n    //     println(\"is 111\")\n    //   case 2 =>\n    //     println(\"is 222\")\n    //   case 3 =>\n    //     println(\"is 333\")\n    //   case _ =>\n    //     println(\"is ---\")\n    \n    \n    // val str = \n    // a0 match\n    //   case 1 => \"one\"\n    //   case 2 => \"two\"\n    //   case 3 => \"three\"\n    //   case _ => \"default\"\n    // println(s\"str: $str\")\n\n\n\n    // while (line = scala.io.StdIn.readLine()) != \"\" do\n    //   println(s\"Read: $line\")\n\n    // while\n    //   val line = readLine()\n    //   println(s\"Read: $line\")\n    //   line != \"!\"\n    // do ()\n\n    // val result = sumTail(List.empty)\n    // val result = maxTail(List.empty)\n    // println(s\"result: $result\")\n\n    // val list = List(100, 32, 345, 774, 105)\n    // val b = max(list)\n    // println(s\"b: $b\")\n\n    // val countList = otpu(5, -3)\n    // println(countList)\n\n    // println(\"\"\"|welcome to chicago 3000.\n    //            |type \"help\" for help.\"\"\".stripMargin)\n    // println(f\"${math.Pi}%.5f\")\n\n    // val aa = f\"$pi is approximately ${math.Pi}%.8f.\"\n    // println(aa)\n\n    // var str = \"\\\\\\\\'\"\n    // var str = raw\"\\\\\\\\'\"\n    // println(str)\n\n\n    // val num = factLog(3)\n    // println(\"num is \" + num)\n\n    // val factTest: Int = factLog(5)\n    // println(\"factTest is \" + factTest)\n    // val factTest: List[Int] =\n    //   List(fact(1), fact(2), fact(3), fact(4), fact(5))\n    // println(\"factTest : \" + factTest)\n    // val n = 6\n    // val result = fib(n)\n    // println(\"num : \" + n + \" result : \" + result)\n\n    // val ll = List.empty\n    // val result = sum(ll)\n    // println(\"result : \" + result)\n    \n    // val pair = (44, \"Lewis\")\n    // val num = pair(0)\n    // val name = pair(1)\n    // println(s\"num: $num - name: $name\")\n\n    // pair(3) = 33\n    // pair(4) = \"Max\"\n    // val num2 = pair(3)\n    // val name2 = pair(4)\n    // println(s\"num2: $num2 - name2: $name2\")\n\n    // var jet = Set(\"Boeing\", \"Airbus\")\n    // jet += \"CAAC\"\n    // println(s\"jet: $jet\")\n\n    // var mutSet = mutable.Set(\"a\", \"b\")\n    // mutSet += \"c\"\n    \n    // scala    swift\n    // array    mutablearray\n    // list     immutablearray\n    // turple   turple\n    // set      set\n    // map      dictionary\n\n    // val map1 = mutable.Map.empty[Int, String]\n    // map1 += (1 -> \"a\")\n    // map1.+=(2 -> \"b\")\n    // map1.update(3, \"c\")\n    // println(s\"map1: $map1\")\n    // println(\"map1(2): \" + map1(2))\n\n    // val map2 = Map(\n    //   \"a\" -> 1,\n    //   \"b\" -> 2,\n    //   \"c\" -> 3\n    // )\n    // println(s\"map2: $map2\")\n    // println(\"map2(\\\"c\\\"): \" + map2(\"c\"))\n\n  //  val list = List(\"hello\", \"qilu\", \"Lewis\")\n  //  val list2 = formatArgs(list)\n  //  println(list2)\n\n  //  val brand = List(\"audi\", \"bmw\", \"mercedes\")\n  //  val newStr = brand.map(element => element + \" car\")\n  //  println(s\"newStr: $newStr\")\n\n  //  val str2 = \n  //    for ele <- brand yield\n  //      ele + \" car\"\n  //  println(s\"str2: $str2\")\n\n  //  val ques = Vector(\"Who\", \"What\", \"When\", \"Where\", \"Why\")\n  //  val usingMap = ques.map(e => e.toLowerCase + \"?\")\n  //  val usingYield = \n  //    for e <- ques yield\n  //      e.toLowerCase + \"?\"\n  //  println(s\"usingMap: $usingMap\")\n  //  println(s\"usingYield: $usingYield\")\n\n  //  val startsW = ques.find(q => q.startsWith(\"W\"))\n  //  val startsH = ques.find(q => q.startsWith(\"H\"))\n  //  val endso = ques.find(q => q.endsWith(\"o\"))\n  //  val hasLen4 = ques.find(q => q.length == 4)\n  //  val hasLen5 = ques.find(q => q.length == 5)\n\n  //  println(s\"startsW: $startsW\")\n  //  println(s\"startsH: $startsH\")\n  //  println(s\"endso: $endso\")\n  //  println(s\"hasLen4: $hasLen4\")\n  //  println(s\"hasLen5: $hasLen5\")\n\n  //  val newstr = startsW.map(s => s.toUpperCase)\n  //  println(\"newstr: \" + newstr)\n\n  //  val newstr2 = startsH.map(s => s.toUpperCase)\n  //  println(\"newstr2: \" + newstr2)\n    // val a = -2.0\n    // val a = (2.0).unary_-\n    // println(a)\n\n    // val str1 = \"Hello World!\"\n    // val str2 = str1 toLowerCase\n    // println(s\"str1: $str1\")\n    // println(s\"str2: $str2\")\n    // println(1==1.0f)\n    // for i <- 1 until 10 do\n    //   println(i)\n    // val filesHere = (new java.io.File(\".\")).listFiles\n    // for file <- filesHere do\n    //   println(file)\n\n    // for file <- filesHere\n    //   if file.isFile\n    //   if file.getName.endsWith(\".scala\") do\n    //     println(file)\n    // val forLineLengths =\n    //   for\n    //     file <- filesHere\n    //     if file.getName.endsWith(\".scala\")\n    //     line <- fileLines(file)\n    //     trimmed = line.trim\n    //     if trimmed.matches(\".*for.*\")\n    //   yield trimmed.length\n    // println(s\"forLineLengths : $forLineLengths\")\n\n    // val a = {var x=1; x = x + 1; x} * {var x = 1; x = x + 1; x}\n    // println(a)\n    // val a = List(List(1,2,3),List(4,5,6))\n    // val a = (1::2::3::Nil).reverse\n    // val a = (1::2::3::Nil) ::: (4::5::6::Nil)\n    // println(a)\n\n  "}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@402a69f, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/Users/qilu/Documents/Git_Code/CSC447/hw/target/scala-3.0.1/zinc/inc_compile_3.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Oct 2, 2021, 3:43:31 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/fp3.scala","languageId":"scala","version":1,"text":"  // GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add code\n * immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n *\n * GRADING\n *\n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and\n *    tests with no compilation errors.  Submissions with compilation errors\n *    will receive 0 points.  Note that refactoring the code will cause the\n *    tests to fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your\n *    submission will result in 0 points for this assignment.\n *\n * 3. You MUST NOT use while loops or (re)assignment to variables (you can\n *    use \"val\" declarations, but not \"var\" declarations).  You must use\n *    recursion instead.\n *\n * 4. You may declare auxiliary functions if you like.\n *\n * SUBMISSION\n *\n * 1. Submit this file on D2L before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be\n *    discussed in class.\n *\n */\n\nobject fp3:\n\n  // EXERCISE 1: complete the following recursive definition of a \"member\"\n  // function to check whether an element \"a\" is a member of a list of\n  // integers \"xs\".\n  //\n  // Your implementation of \"member\" MUST be recursive and not use the\n  // builtin \"contains\" method from the List class.\n  //\n  // EXAMPLES:\n  // - member (5, List (4, 6, 8, 5)) == true\n  // - member (3, List (4, 6, 8, 5)) == false\n  def member(a: Int, xs: List[Int]): Boolean =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 2: complete the following recursive definition of an \"allEqual\"\n  // function to check whether all elements in a list of integers are equal.\n  //\n  // EXAMPLES:\n  // - allEqual (Nil) == true\n  // - allEqual (List (5)) == true\n  // - allEqual (List (5, 5, 5)) == true\n  // - allEqual (List (6, 5, 5, 5)) == false\n  // - allEqual (List (5, 5, 6, 5)) == false\n  // - allEqual (List (5, 5, 5, 6)) == false\n  def allEqual(xs: List[Int]): Boolean =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 3: complete the definition of the following function that\n  // computes the length of each String in a list, and returns the original\n  // Strings paired with their length.  For example:\n  //\n  //   stringLengths (List (\"the\", \"rain\")) == List ((\"the\", 3), (\"rain\", 4))\n  //\n  // You must not use recursion directly in the function.\n  //\n  // You can use the \"map\" method of the List class.\n  def stringLengths(xs: List[String]): List[(String, Int)] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 4: complete the function definition for \"delete1\" that takes\n  // an element \"x\" and a list \"ys\", then returns the list where any\n  // occurrences of \"x\" in \"ys\" have been removed.\n  //\n  // Your definition of \"delete1\" MUST be recursive.\n  //\n  // EXAMPLE:\n  // - delete1 (\"the\", List (\"the\",\"the\",\"was\",\"a\",\"product\",\"of\",\"the\",\"1980s\"))\n  //                == List (\"was\",\"a\",\"product\",\"of\",\"1980s\")\n  def delete1[X](x: X, ys: List[X]): List[X] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n\n  // EXERCISE 5: complete the function definition for \"delete2\" below.  It\n  // must have the same behavior as \"delete1\".\n  //\n  // It must be written using \"for comprehensions\" and not use recursion\n  // explicitly.\n  def delete2[X](x: X, ys: List[X]): List[X] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 6: complete the function definition for \"delete3\" below.  It\n  // must have the same behavior as \"delete1\".\n  //\n  // It must be written using the builtin \"filter\" method for Lists and not\n  // use recursion explicitly.\n  def delete3[X](x: X, ys: List[X]): List[X] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 7: complete the function definition for \"removeDupes1\" below.\n  // It takes a list as argument, then returns the same list with consecutive\n  // duplicate elements compacted to a single element.\n  //\n  // Duplicate elements that are separated by at least one distinct element\n  // should be left alone.\n  //\n  // EXAMPLE:\n  // - removeDupes1 (List (1,1,2,3,3,3,4,4,5,6,7,7,8,9,2,2,2,9))\n  //              == List (1,2,3,4,5,6,7,8,9,2,9)\n  def removeDupes1[X](xs: List[X]): List[X] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n\n\n\n  // EXERCISE 8: write a function \"removeDupes2\" that behaves like\n  // \"removeDupes1\", but also includes a count of the number of consecutive\n  // duplicate elements in the original list (thus producing a simple\n  // run-length encoding).  The counts are paired with each element in the\n  // output list.\n  //\n  // EXAMPLE:\n  // - removeDupes2 (List (1,1,2,3,3,3,4,4,5,6,7,7,8,9,2,2,2,9))\n  //              == List ((2,1),(1,2),(3,3),(2,4),(1,5),(1,6),(2,7),(1,8),(1,9),(3,2),(1,9))\n  def removeDupes2[X](xs: List[X]): List[(Int, X)] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n\n\n  // EXERCISE 9: complete the following definition of a function that splits\n  // a list into a pair of two lists.  The offset for the the split position\n  // is given by the Int argument.\n  //\n  // The behavior is determined by:\n  //\n  //   for all n, xs:\n  //     splitAt (n, xs) == (take (n, xs), drop (n, xs))\n  //\n  // Some examples:\n  // splitAt(0,List(        31,41,51)) --> (List(       ), List(31,41,51))\n  // splitAt(1,List(     21,31,41,51)) --> (List(     21), List(31,41,51))\n  // splitAt(2,List(  11,21,31,41,51)) --> (List(  11,21), List(31,41,51))\n  // splitAt(3,List(1,11,21,31,41,51)) --> (List(1,11,21), List(31,41,51))\n  //\n  // splitAt(3,     List())  --> (List(     ), List())\n  // splitAt(4,   List(51))  --> (List(   51), List())\n  // splitAt(5,List(41,51))  --> (List(41,51), List())\n  //\n  // Your definition of \"splitAt\" must be recursive and must not use \"take\"\n  // or \"drop\".\n  //\n  // Your definition of \"splitAt\" must only travere the list once.  So you\n  // cannot define your own versions of \"take\"/\"drop\" and use them (because\n  // that would entail one traversal of the list with \"take\" and then a\n  // second traversal with \"drop\").\n  //\n\n  def splitAt[X](n: Int, xs: List[X]): (List[X], List[X]) =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n\n  // EXERCISE 10: complete the following definition of an \"allDistinct\"\n  // function that checks whether all values in list are distinct.  You\n  // should use your \"member\" function defined earlier.\n  //\n  // Your implementation must be recursive.\n  //\n  // EXAMPLE:\n  // - allDistinct (Nil) == true\n  // - allDistinct (List (1,2,3,4,5)) == true\n  // - allDistinct (List (1,2,3,4,5,1)) == false\n  // - allDistinct (List (1,2,3,2,4,5)) == false\n  def allDistinct(xs: List[Int]): Boolean =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n"}})[0m
