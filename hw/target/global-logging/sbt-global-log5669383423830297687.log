[0m[[0m[0mdebug[0m] [0m[0m> Exec(;Test/compile; collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(Test/compile, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Test / compile[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@379ddab2, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskStart, {"taskId":{"id":"8","parents":[]},"eventTime":1632687815227,"message":"Compiling hw","dataKind":"compile-task","data":{"target":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Compile"}}})[0m
[0m[[0m[0minfo[0m] [0m[0mcompiling 1 Scala source to /Users/qilu/Documents/Git_Code/CSC447/hw/target/scala-3.0.1/classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":3,"message":"compiling 1 Scala source to /Users/qilu/Documents/Git_Code/CSC447/hw/target/scala-3.0.1/classes ..."})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/storage.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Compile"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/subtyping.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Compile"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/fp1.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Compile"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/fp3.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Compile"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/dynamic.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Compile"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/fp2.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Compile"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/interpreter.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Compile"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/argpass.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Compile"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskFinish, {"taskId":{"id":"8","parents":[]},"eventTime":1632687817677,"message":"Compiled hw","status":1,"dataKind":"compile-report","data":{"target":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Compile"},"errors":0,"warnings":0,"time":2450}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskStart, {"taskId":{"id":"9","parents":[]},"eventTime":1632687817760,"message":"Compiling hw-test","dataKind":"compile-task","data":{"target":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/test/scala/subtypingtests.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/test/scala/storagetests.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/test/scala/UnitSpec.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/test/scala/dynamictests.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/test/scala/fp3tests.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/test/scala/interpretertests.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/test/scala/fp1tests.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/test/scala/argpasstests.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/publishDiagnostics, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/test/scala/fp2tests.scala"},"buildTarget":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"},"diagnostics":[],"reset":true})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskFinish, {"taskId":{"id":"9","parents":[]},"eventTime":1632687817813,"message":"Compiled hw-test","status":1,"dataKind":"compile-report","data":{"target":{"uri":"file:/Users/qilu/Documents/Git_Code/CSC447/hw/#hw/Test"},"errors":0,"warnings":0,"time":53}})[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 3 s, completed Sep 26, 2021, 3:23:37 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@6f8af186, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/Users/qilu/Documents/Git_Code/CSC447/hw/target/scala-3.0.1/zinc/inc_compile_3.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Sep 26, 2021, 3:23:37 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/fp2.scala","languageId":"scala","version":1,"text":"  // GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add\n * code immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n *\n * GRADING\n *\n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and\n *    tests with no compilation errors.  Submissions with compilation errors\n *    will receive 0 points.  Note that refactoring the code will cause the\n *    tests to fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your\n *    submission will result in 0 points for this assignment.\n *\n * 3. You MUST NOT use while loops or (re)assignment to variables (you can\n *    use \"val\" declarations, but not \"var\" declarations).  You must use\n *    recursion instead.\n *\n * 4. You may declare auxiliary functions if you like.\n *\n * SUBMISSION\n *\n * 1. Submit this file on D2L before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be\n *    discussed in class.\n *\n */\n\nimport java.util.NoSuchElementException\nobject fp2:\n\n  // EXERCISE 1: complete the following recursive definition of a \"map\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \"map\" method.\n  //\n  // Your implementation of \"map\" MUST be recursive.\n  def map[A, B](xs: List[A], f: A => B): List[B] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 2: complete the following recursive definition of a \"filter\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \"filter\" method.\n  //\n  // Your implementation of \"filter\" MUST be recursive.\n  def filter[A](xs: List[A], f: A => Boolean): List[A] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 3: complete the following recursive definition of an \"append\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \":::\" method.\n  //\n  // Your implementation of \"append\" MUST be recursive.\n  //\n  // HINT: use \"::\" in the body of the cons-cell case.\n  def append[A](xs: List[A], ys: List[A]): List[A] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 4: complete the following recursive definition of a \"flatten\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \"flatten\" method.\n  //\n  // Your implementation of \"flatten\" MUST be recursive.\n  //\n  // HINT: use either \":::\" or your definition of \"append\" in the body of the\n  // cons-cell case.\n  //\n  // EXAMPLE:\n  // - flatten (List ((1 to 5).toList, (6 to 10).toList, (11 to 15).toList)) == (1 to 15).toList\n  def flatten[A](xss: List[List[A]]): List[A] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 5: complete the following recursive definition of a \"foldLeft\"\n  // function for Scala's builtin list type.  You must not use the builtin\n  // \"foldLeft\" method.\n  //\n  // Your implementation of \"foldLeft\" MUST be recursive.\n  //\n  // HINT:   foldLeft (  Nil, e, f) == e\n  //         foldLeft (y::ys, e, f) == foldLeft (ys, f (e, y), f)\n  def foldLeft[A, B](xs: List[A], e: B, f: (B, A) => B): B =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 6: complete the following recursive definition of a \"foldRight\"\n  // function for Scala's builtin list type.  You must not use the builtin\n  // \"foldRight\" method.\n  //\n  // Your implementation of \"foldRight\" MUST be recursive.\n  //\n  // HINT:   foldRight (  Nil, e, f) == e\n  //         foldRight (y::ys, e, f) == f (y, foldRight (ys, e, f))\n  def foldRight[A, B](xs: List[A], e: B, f: (A, B) => B): B =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 7: complete the following definition of a \"joinTerminateRight\"\n  // function to take a list of strings \"xs\" and concatenate all strings\n  // using a string \"term\" as a terminator (not delimiter) between strings.\n  //\n  // You MUST use your foldRight defined above.\n  //\n  // You MAY NOT use recursion.\n  //\n  // EXAMPLES:\n  // - joinTerminateRight (Nil, \";\") == \"\"\n  // - joinTerminateRight (List (\"a\"), \";\") == \"a;\"\n  // - joinTerminateRight (List (\"a\",\"b\",\"c\",\"d\"), \";\") == \"a;b;c;d;\"\n  def joinTerminateRight(xs: List[String], term: String): String =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 8: complete the following definition of a \"joinTerminateLeft\"\n  // function to take a list of strings \"xs\" and concatenate all strings\n  // using a string \"term\" as a terminator (not delimiter) between strings.\n  //\n  // You MUST use your foldLeft defined above.\n  //\n  // You MAY NOT use recursion.\n  //\n  // EXAMPLES:\n  // - joinTerminateLeft (Nil, \";\") == \"\"\n  // - joinTerminateLeft (List (\"a\"), \";\") == \"a;\"\n  // - joinTerminateLeft (List (\"a\",\"b\",\"c\",\"d\"), \";\") == \"a;b;c;d;\"\n  def joinTerminateLeft(xs: List[String], term: String): String =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 9: complete the following recursive definition of a\n  // \"firstNumGreaterThan\" function to find the first number greater than or\n  // equal to \"a\" in a list of integers \"xs\".\n  //\n  // If the list is empty or there is no number greater than or equal to \"a\",\n  // throw a java.util.NoSuchElementException (with no argument).\n  //\n  // Your implementation of \"firstNumGreaterThan\" MUST be recursive.\n  //\n  // EXAMPLES:\n  // - firstNumGreaterThan (5, List (4, 6, 8, 5)) == 6\n  def firstNumGreaterThan(a: Int, xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 10: complete the following recursive definition of a\n  // \"firstIndexNumGreaterThan\" function to find the index (position) of the\n  // first number greater than or equal to \"a\" in a list of integers \"xs\".\n  //\n  // The first index should be zero (not one).\n  //\n  // If the list is empty or there is no number greater than or equal to \"a\",\n  // throw a java.util.NoSuchElementException (with no argument).\n  //\n  // Your implementation of \"firstIndexNumGreaterThan\" MUST be recursive.\n  //\n  // EXAMPLES:\n  // - firstIndexNumGreaterThan (5, List (4, 6, 8, 5)) == 1\n  //\n  // HINT: this is a bit easier to write if you use an auxiliary function.\n  def firstIndexNumGreaterThan(a: Int, xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/fp2.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/fp3.scala","languageId":"scala","version":1,"text":"  // GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add code\n * immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n *\n * GRADING\n *\n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and\n *    tests with no compilation errors.  Submissions with compilation errors\n *    will receive 0 points.  Note that refactoring the code will cause the\n *    tests to fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your\n *    submission will result in 0 points for this assignment.\n *\n * 3. You MUST NOT use while loops or (re)assignment to variables (you can\n *    use \"val\" declarations, but not \"var\" declarations).  You must use\n *    recursion instead.\n *\n * 4. You may declare auxiliary functions if you like.\n *\n * SUBMISSION\n *\n * 1. Submit this file on D2L before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be\n *    discussed in class.\n *\n */\n\nobject fp3:\n\n  // EXERCISE 1: complete the following recursive definition of a \"member\"\n  // function to check whether an element \"a\" is a member of a list of\n  // integers \"xs\".\n  //\n  // Your implementation of \"member\" MUST be recursive and not use the\n  // builtin \"contains\" method from the List class.\n  //\n  // EXAMPLES:\n  // - member (5, List (4, 6, 8, 5)) == true\n  // - member (3, List (4, 6, 8, 5)) == false\n  def member(a: Int, xs: List[Int]): Boolean =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 2: complete the following recursive definition of an \"allEqual\"\n  // function to check whether all elements in a list of integers are equal.\n  //\n  // EXAMPLES:\n  // - allEqual (Nil) == true\n  // - allEqual (List (5)) == true\n  // - allEqual (List (5, 5, 5)) == true\n  // - allEqual (List (6, 5, 5, 5)) == false\n  // - allEqual (List (5, 5, 6, 5)) == false\n  // - allEqual (List (5, 5, 5, 6)) == false\n  def allEqual(xs: List[Int]): Boolean =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 3: complete the definition of the following function that\n  // computes the length of each String in a list, and returns the original\n  // Strings paired with their length.  For example:\n  //\n  //   stringLengths (List (\"the\", \"rain\")) == List ((\"the\", 3), (\"rain\", 4))\n  //\n  // You must not use recursion directly in the function.\n  //\n  // You can use the \"map\" method of the List class.\n  def stringLengths(xs: List[String]): List[(String, Int)] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 4: complete the function definition for \"delete1\" that takes\n  // an element \"x\" and a list \"ys\", then returns the list where any\n  // occurrences of \"x\" in \"ys\" have been removed.\n  //\n  // Your definition of \"delete1\" MUST be recursive.\n  //\n  // EXAMPLE:\n  // - delete1 (\"the\", List (\"the\",\"the\",\"was\",\"a\",\"product\",\"of\",\"the\",\"1980s\"))\n  //                == List (\"was\",\"a\",\"product\",\"of\",\"1980s\")\n  def delete1[X](x: X, ys: List[X]): List[X] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n\n  // EXERCISE 5: complete the function definition for \"delete2\" below.  It\n  // must have the same behavior as \"delete1\".\n  //\n  // It must be written using \"for comprehensions\" and not use recursion\n  // explicitly.\n  def delete2[X](x: X, ys: List[X]): List[X] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 6: complete the function definition for \"delete3\" below.  It\n  // must have the same behavior as \"delete1\".\n  //\n  // It must be written using the builtin \"filter\" method for Lists and not\n  // use recursion explicitly.\n  def delete3[X](x: X, ys: List[X]): List[X] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 7: complete the function definition for \"removeDupes1\" below.\n  // It takes a list as argument, then returns the same list with consecutive\n  // duplicate elements compacted to a single element.\n  //\n  // Duplicate elements that are separated by at least one distinct element\n  // should be left alone.\n  //\n  // EXAMPLE:\n  // - removeDupes1 (List (1,1,2,3,3,3,4,4,5,6,7,7,8,9,2,2,2,9))\n  //              == List (1,2,3,4,5,6,7,8,9,2,9)\n  def removeDupes1[X](xs: List[X]): List[X] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n\n\n\n  // EXERCISE 8: write a function \"removeDupes2\" that behaves like\n  // \"removeDupes1\", but also includes a count of the number of consecutive\n  // duplicate elements in the original list (thus producing a simple\n  // run-length encoding).  The counts are paired with each element in the\n  // output list.\n  //\n  // EXAMPLE:\n  // - removeDupes2 (List (1,1,2,3,3,3,4,4,5,6,7,7,8,9,2,2,2,9))\n  //              == List ((2,1),(1,2),(3,3),(2,4),(1,5),(1,6),(2,7),(1,8),(1,9),(3,2),(1,9))\n  def removeDupes2[X](xs: List[X]): List[(Int, X)] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n\n\n  // EXERCISE 9: complete the following definition of a function that splits\n  // a list into a pair of two lists.  The offset for the the split position\n  // is given by the Int argument.\n  //\n  // The behavior is determined by:\n  //\n  //   for all n, xs:\n  //     splitAt (n, xs) == (take (n, xs), drop (n, xs))\n  //\n  // Some examples:\n  // splitAt(0,List(        31,41,51)) --> (List(       ), List(31,41,51))\n  // splitAt(1,List(     21,31,41,51)) --> (List(     21), List(31,41,51))\n  // splitAt(2,List(  11,21,31,41,51)) --> (List(  11,21), List(31,41,51))\n  // splitAt(3,List(1,11,21,31,41,51)) --> (List(1,11,21), List(31,41,51))\n  //\n  // splitAt(3,     List())  --> (List(     ), List())\n  // splitAt(4,   List(51))  --> (List(   51), List())\n  // splitAt(5,List(41,51))  --> (List(41,51), List())\n  //\n  // Your definition of \"splitAt\" must be recursive and must not use \"take\"\n  // or \"drop\".\n  //\n  // Your definition of \"splitAt\" must only travere the list once.  So you\n  // cannot define your own versions of \"take\"/\"drop\" and use them (because\n  // that would entail one traversal of the list with \"take\" and then a\n  // second traversal with \"drop\").\n  //\n\n  def splitAt[X](n: Int, xs: List[X]): (List[X], List[X]) =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n\n  // EXERCISE 10: complete the following definition of an \"allDistinct\"\n  // function that checks whether all values in list are distinct.  You\n  // should use your \"member\" function defined earlier.\n  //\n  // Your implementation must be recursive.\n  //\n  // EXAMPLE:\n  // - allDistinct (Nil) == true\n  // - allDistinct (List (1,2,3,4,5)) == true\n  // - allDistinct (List (1,2,3,4,5,1)) == false\n  // - allDistinct (List (1,2,3,2,4,5)) == false\n  def allDistinct(xs: List[Int]): Boolean =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/fp3.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/fp2.scala","languageId":"scala","version":1,"text":"  // GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add\n * code immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n *\n * GRADING\n *\n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and\n *    tests with no compilation errors.  Submissions with compilation errors\n *    will receive 0 points.  Note that refactoring the code will cause the\n *    tests to fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your\n *    submission will result in 0 points for this assignment.\n *\n * 3. You MUST NOT use while loops or (re)assignment to variables (you can\n *    use \"val\" declarations, but not \"var\" declarations).  You must use\n *    recursion instead.\n *\n * 4. You may declare auxiliary functions if you like.\n *\n * SUBMISSION\n *\n * 1. Submit this file on D2L before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be\n *    discussed in class.\n *\n */\n\nimport java.util.NoSuchElementException\nobject fp2:\n\n  // EXERCISE 1: complete the following recursive definition of a \"map\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \"map\" method.\n  //\n  // Your implementation of \"map\" MUST be recursive.\n  def map[A, B](xs: List[A], f: A => B): List[B] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 2: complete the following recursive definition of a \"filter\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \"filter\" method.\n  //\n  // Your implementation of \"filter\" MUST be recursive.\n  def filter[A](xs: List[A], f: A => Boolean): List[A] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 3: complete the following recursive definition of an \"append\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \":::\" method.\n  //\n  // Your implementation of \"append\" MUST be recursive.\n  //\n  // HINT: use \"::\" in the body of the cons-cell case.\n  def append[A](xs: List[A], ys: List[A]): List[A] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 4: complete the following recursive definition of a \"flatten\"\n  // function for Scala's builtin List type.  You must not use the builtin\n  // \"flatten\" method.\n  //\n  // Your implementation of \"flatten\" MUST be recursive.\n  //\n  // HINT: use either \":::\" or your definition of \"append\" in the body of the\n  // cons-cell case.\n  //\n  // EXAMPLE:\n  // - flatten (List ((1 to 5).toList, (6 to 10).toList, (11 to 15).toList)) == (1 to 15).toList\n  def flatten[A](xss: List[List[A]]): List[A] =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 5: complete the following recursive definition of a \"foldLeft\"\n  // function for Scala's builtin list type.  You must not use the builtin\n  // \"foldLeft\" method.\n  //\n  // Your implementation of \"foldLeft\" MUST be recursive.\n  //\n  // HINT:   foldLeft (  Nil, e, f) == e\n  //         foldLeft (y::ys, e, f) == foldLeft (ys, f (e, y), f)\n  def foldLeft[A, B](xs: List[A], e: B, f: (B, A) => B): B =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 6: complete the following recursive definition of a \"foldRight\"\n  // function for Scala's builtin list type.  You must not use the builtin\n  // \"foldRight\" method.\n  //\n  // Your implementation of \"foldRight\" MUST be recursive.\n  //\n  // HINT:   foldRight (  Nil, e, f) == e\n  //         foldRight (y::ys, e, f) == f (y, foldRight (ys, e, f))\n  def foldRight[A, B](xs: List[A], e: B, f: (A, B) => B): B =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 7: complete the following definition of a \"joinTerminateRight\"\n  // function to take a list of strings \"xs\" and concatenate all strings\n  // using a string \"term\" as a terminator (not delimiter) between strings.\n  //\n  // You MUST use your foldRight defined above.\n  //\n  // You MAY NOT use recursion.\n  //\n  // EXAMPLES:\n  // - joinTerminateRight (Nil, \";\") == \"\"\n  // - joinTerminateRight (List (\"a\"), \";\") == \"a;\"\n  // - joinTerminateRight (List (\"a\",\"b\",\"c\",\"d\"), \";\") == \"a;b;c;d;\"\n  def joinTerminateRight(xs: List[String], term: String): String =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 8: complete the following definition of a \"joinTerminateLeft\"\n  // function to take a list of strings \"xs\" and concatenate all strings\n  // using a string \"term\" as a terminator (not delimiter) between strings.\n  //\n  // You MUST use your foldLeft defined above.\n  //\n  // You MAY NOT use recursion.\n  //\n  // EXAMPLES:\n  // - joinTerminateLeft (Nil, \";\") == \"\"\n  // - joinTerminateLeft (List (\"a\"), \";\") == \"a;\"\n  // - joinTerminateLeft (List (\"a\",\"b\",\"c\",\"d\"), \";\") == \"a;b;c;d;\"\n  def joinTerminateLeft(xs: List[String], term: String): String =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 9: complete the following recursive definition of a\n  // \"firstNumGreaterThan\" function to find the first number greater than or\n  // equal to \"a\" in a list of integers \"xs\".\n  //\n  // If the list is empty or there is no number greater than or equal to \"a\",\n  // throw a java.util.NoSuchElementException (with no argument).\n  //\n  // Your implementation of \"firstNumGreaterThan\" MUST be recursive.\n  //\n  // EXAMPLES:\n  // - firstNumGreaterThan (5, List (4, 6, 8, 5)) == 6\n  def firstNumGreaterThan(a: Int, xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 10: complete the following recursive definition of a\n  // \"firstIndexNumGreaterThan\" function to find the index (position) of the\n  // first number greater than or equal to \"a\" in a list of integers \"xs\".\n  //\n  // The first index should be zero (not one).\n  //\n  // If the list is empty or there is no number greater than or equal to \"a\",\n  // throw a java.util.NoSuchElementException (with no argument).\n  //\n  // Your implementation of \"firstIndexNumGreaterThan\" MUST be recursive.\n  //\n  // EXAMPLES:\n  // - firstIndexNumGreaterThan (5, List (4, 6, 8, 5)) == 1\n  //\n  // HINT: this is a bit easier to write if you use an auxiliary function.\n  def firstIndexNumGreaterThan(a: Int, xs: List[Int]): Int =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, ♨1, shutdown, null})[0m
