[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/qilu/Documents/Git_Code/CSC447/hw/src/main/scala/argpass.scala","languageId":"scala","version":1,"text":"  // GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add code\n * immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n *\n * GRADING\n *\n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and\n *    tests with no compilation errors.  Submissions with compilation errors\n *    will receive 0 points.  Note that refactoring the code will cause the\n *    tests to fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your\n *    submission will result in 0 points for this assignment.\n *\n * 3. You MUST NOT use while loops or (re)assignment to variables (you can\n *    use \"val\" declarations, but not \"var\" declarations).  You must use\n *    recursion instead.\n *\n * 4. You may declare auxiliary functions if you like.\n *\n * SUBMISSION\n *\n * 1. Submit this file on D2L before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be\n *    discussed in class.\n *\n */\n\nobject argpass:\n\n  class RefInt(initial: Int):\n    private var n: Int = initial\n    def get(): Int = n\n    def set(m: Int): Unit = { n = m }\n\n  // EXERCISE 1: complete the following higher-order function.  It has one\n  // parameter f: a function that takes an instance of RefInt (see above for\n  // the definition of the class RefInt) and returns Unit (i.e., nothing\n  // interesting).\n  //\n  // Your code must create ONLY ONE instance of RefInt, then call f three times.\n  // f will update the integer stored in the instances of RefInt it is given.\n  //\n  // Your code must return a tuple of the three integers provided by f in the\n  // order that they came back from calls, i.e., the integer from the first\n  // call to f is the first integer in the returned tuple.\n  def refint1(f: RefInt => Unit): (Int, Int, Int) =\n    // TODO: Provide definition here.\n    // Example call:\n    // val r = RefInt (0)\n    // f (r)\n    // val n : Int = r.get()\n    throw UnsupportedOperationException()\n\n  // EXERCISE 2: complete the following higher-order function.  It has one\n  // parameter f: a function that takes an instance of RefInt (see above for\n  // the definition of the class RefInt) and returns Unit (i.e., nothing\n  // interesting).\n  //\n  // Your code must create EXACTLY THREE instances of RefInt, then call f\n  // three times.  f will update the integer stored in the instances of\n  // RefInt it is given.  However, f will not do this update immediately.  It\n  // will only do it after the third call to f: at that point it updates all\n  // three instances of RefInt that it has received as arguments so far.\n  //\n  // Your code must return a tuple of the three integers provided by f in the\n  // order that they came back from calls, i.e., the integer from the first\n  // call to f is the first integer in the returned tuple.\n  def refint2(f: RefInt => Unit): (Int, Int, Int) =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 3: complete the following function.  It has one parameter r: (a\n  // reference to) an instance of RefInt (see above for the definition of the\n  // class RefInt) and returns (a reference to) an instance of RefInt.\n  //\n  // Your code must increment (add 1 to) the RefInt it receives and return\n  // double the original value (stored in a separate RefInt instance) as the\n  // result.\n  def refint3(r: RefInt): RefInt =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 4: complete the following function.\n  // It has two parameters\n  // - r: (a reference to) an instance of RefInt (see above for the\n  //      definition of the class RefInt); AND\n  // - f: a function that accepts (a reference to) an instance of RefInt.\n  //\n  // Your code must call f with a *copy* of the RefInt r, i.e., it must make\n  // a new instance of RefInt with the same Int.\n  //\n  // Your code should return true if f has NOT changed the Int stored in the\n  // copy of r.  Otherwise it should return false.\n  def refint4(r: RefInt, f: RefInt => Unit): Boolean =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n\n  // EXERCISE 5: complete the following function.  It has one parameter: a\n  // list of (references to) RefInt instances.\n  //\n  // Your code must CHANGE the argument it receives in a way that is visible\n  // to the caller.  Note that this is the Scala List type, which is\n  // immutable!  You can assume that the list you receive is not empty.\n  def refint5(xs: List[RefInt]): Unit =\n    // TODO: Provide definition here.\n    throw UnsupportedOperationException()\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: bloop.integrations.sbt.Offloader$$anon$1@6c2883b1, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/Users/qilu/Documents/Git_Code/CSC447/hw/target/scala-3.0.1/zinc/inc_compile_3.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Oct 24, 2021, 11:51:59 AM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///Users/qilu/Library/Mobile%20Documents/com~apple~CloudDocs/Documents/Class/CSC%20447/Quiz%E7%AD%94%E6%A1%88/CSC-447-Concepts-of-Programming-Languages-master/argpass.scala","languageId":"scala","version":1,"text":"// GENERATED\n/* INSTRUCTIONS\n *\n * Complete the exercises below.  For each \"EXERCISE\" comment, add\n * code immediately below the comment.\n *\n * Please see README.md for instructions, including compilation and testing.\n * \n * GRADING\n * \n * 1. Submissions MUST compile using SBT with UNCHANGED configuration and tests with no\n *    compilation errors.  Submissions with compilation errors will receive 0 points.\n *    Note that refactoring the code will cause the tests to fail.\n *\n * 2. You MUST NOT edit the SBT configuration and tests.  Altering it in your submission will\n *    result in 0 points for this assignment.\n *\n * 3. You MUST NOT use while loops or (re)assignment to variables (you can use \"val\" declarations,\n *    but not \"var\" declarations).  You must use recursion instead.\n *\n * 4. You may declare auxiliary functions if you like.\n *\n * SUBMISSION\n *\n * 1. Push your local repository to the repository created for you on Bitbucket before the deadline.\n *\n * 2. Late submissions will not be permitted because solutions will be discussed in class.\n * \n */\n\nobject argpass {\n\n  class RefInt (initial : Int) {\n    private var n : Int = initial \n    def get () : Int = n \n    def set (m : Int) : Unit = { n = m }\n }\n\n  // EXERCISE 1: complete the following higher-order function.\n  // It has one parameter f: a function that takes an instance of RefInt (see above for the definition of the class RefInt) and returns Unit (i.e., nothing interesting).\n  // Your code must create ONLY ONE instance of RefInt, then call f three times.\n  // f will update the integer stored in the instances of RefInt it is given.\n  // Your code must return a tuple of the three integers provided by f in the order that they came back from calls, i.e., the integer from the first call to f is the first integer in the returned tuple.\n  def refint1 (f : RefInt => Unit) : (Int, Int, Int) = {\n    // TODO: Provide definition here.\n    // Example call:\n    // val r = new RefInt (0)\n    // f (r)\n    // val n : Int = r.get\n    val a1 = new RefInt(10)\n    f(a1)\n    val m  = a1.get()\n    a1.set(20)\n    f(a1)\n    val n  = a1.get()\n    a1.set(30)\n    f(a1)\n    val p = a1.get()\n    return(m,n,p)\n  }\n\n  // EXERCISE 2: complete the following higher-order function.\n  // It has one parameter f: a function that takes an instance of RefInt (see above for the definition of the class RefInt) and returns Unit (i.e., nothing interesting).\n  // Your code must create EXACTLY THREE instances of RefInt, then call f three times.\n  // f will update the integer stored in the instances of RefInt it is given.\n  // However, f will not do this update immediately.  \n  // It will only do it after the third call to f: at that point it updates all three instances of RefInt that it has received as arguments so far.\n  // Your code must return a tuple of the three integers provided by f in the order that they came back from calls, i.e., the integer from the first call to f is the first integer in the returned tuple.\n  def refint2 (f : RefInt => Unit) : (Int, Int, Int) = {\n    val a1 = new RefInt(10)\n    f(a1)\n    val a2 = new RefInt(200)\n    f(a2)\n    val a3 = new RefInt(300)\n    f(a3)\n    return (a1.get(),a2.get(),a3.get())\n  }\n\n  // EXERCISE 3: complete the following function.\n  // It has one parameter r: (a reference to) an instance of RefInt (see above for the definition of the class RefInt) and returns (a reference to) an instance of RefInt.\n  // Your code must increment (add 1 to) the RefInt it receives and return double the original value (stored in a separate RefInt instance) as the result.\n  def refint3 (r : RefInt) : RefInt = {\n    val a = r.get()\n    val y = a+1\n    r.set(y)\n    val b = new RefInt(2*a)\n    return b\n  }\n\n  // EXERCISE 4: complete the following function.\n  // It has two parameters\n  // - r: (a reference to) an instance of RefInt (see above for the definition of the class RefInt); AND\n  // - f: a function that accepts (a reference to) an instance of RefInt.\n  // Your code must call f with a *copy* of the RefInt r, i.e., it must make a new instance of RefInt with the same Int.\n  // Your code should return true if f has NOT changed the Int stored in the copy of r.  Otherwise it should return false.\n  def refint4 (r : RefInt, f : RefInt => Unit) : Boolean = {\n    val a = r.get()\n    val a1 = new RefInt(a)\n    f(a1)\n    val m = a1.get()\n    if(a != m) return false\n    else return true\n  }\n\n  // EXERCISE 5: complete the following function.\n  // It has one parameter: a list of (references to) RefInt instances.\n  // Your code must CHANGE the argument it receives in a way that is visible to the caller.\n  // Note that this is the Scala List type, which is immutable!\n  // You can assume that the list you receive is not empty.\n  def refint5 (xs : List[RefInt]) : Unit = {\n    for(x <-xs){\n      var a = x.get()\n      x.set(a+1)\n    }\n  }\n}\n\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, ♨1, shutdown, null})[0m
